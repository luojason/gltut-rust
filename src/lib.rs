//! Contains various re-usable functionalities employed throughout the different examples.

use std::{ffi::CString, num::NonZeroU32};

use anyhow::{anyhow, Context};
use glutin::prelude::*;
use glutin::{display::GetGlDisplay, surface};
use winit::{dpi, event_loop, raw_window_handle::HasWindowHandle, window};

pub mod app;
pub mod glutil;

// Hard-coded constants for simplicity
const WIDTH: NonZeroU32 = unsafe { NonZeroU32::new_unchecked(800) };
const HEIGHT: NonZeroU32 = unsafe { NonZeroU32::new_unchecked(800) };

/// Initializes a window with an OpenGL context.
///
/// # Safety
///
/// The [`Window`](winit::window::Window) returned by this method must live at least as long as the
/// [`PossiblyCurrentContext`](glutin::context::PossiblyCurrentContext) and [`Surface`](surface::Surface)
/// returned by this method.
///
/// This is because those objects may rely on the `RawWindowHandle` generated by that `Window`.
pub unsafe fn init_window_and_context() -> Result<
    (
        event_loop::EventLoop<()>,
        window::Window,
        glutin::context::PossiblyCurrentContext,
        surface::Surface<surface::WindowSurface>,
    ),
    Box<dyn std::error::Error>,
> {
    let event_loop = event_loop::EventLoop::new().context("failed to create event loop")?;
    event_loop.set_control_flow(event_loop::ControlFlow::Wait);

    let window_attr = window::Window::default_attributes()
        .with_inner_size(dpi::PhysicalSize::new(WIDTH.get(), HEIGHT.get()))
        .with_title("OpenGL tutorial");
    let template_builder = glutin::config::ConfigTemplateBuilder::new().with_alpha_size(8);
    let (window, gl_config) = glutin_winit::DisplayBuilder::new()
        .with_window_attributes(Some(window_attr))
        .build(&event_loop, template_builder, gl_config_picker)?;
    let window = window.ok_or(anyhow!(
        "window not initialized immediately, may need finalize_window for this platform"
    ))?;
    let raw_window_handle = window
        .window_handle()
        .context("failed to obtain raw window handle")?
        .as_raw();
    let gl_display = gl_config.display();

    // create OpenGL context
    let context_attr =
        glutin::context::ContextAttributesBuilder::new().build(Some(raw_window_handle));
    // SAFETY: see function documentation above
    let gl_context = unsafe {
        gl_display
            .create_context(&gl_config, &context_attr)
            .context("failed to create GL context")?
    };

    let surface_attrs = surface::SurfaceAttributesBuilder::<surface::WindowSurface>::new()
        .with_single_buffer(false)
        .build(raw_window_handle, WIDTH, HEIGHT);
    // SAFETY: see function documentation above
    let surface = unsafe {
        gl_display
            .create_window_surface(&gl_config, &surface_attrs)
            .context("failed to create window surface for rendering")?
    };

    // make gl_context current
    let gl_context = gl_context
        .make_current(&surface)
        .map_err(anyhow::Error::new)
        .and_then(|c| {
            // verify the context was actually made current
            if c.is_current() {
                Ok(c)
            } else {
                Err(anyhow!(
                    "context not current after `make_current`. Context: {:?}",
                    c
                ))
            }
        })
        .context("failed to make GL context current on the window surface")?;

    // load OpenGL function pointers from the initialized context
    gl::load_with(|s| {
        let cstr = CString::new(s).unwrap();
        gl_display.get_proc_address(&cstr)
    });

    Ok((event_loop, window, gl_context, surface))
}

// Copied from https://github.com/rust-windowing/glutin/blob/master/glutin_examples/src/lib.rs
/// Selects the config with the highest sample count which supports transparency
fn gl_config_picker(
    configs: Box<dyn Iterator<Item = glutin::config::Config> + '_>,
) -> glutin::config::Config {
    configs
        .reduce(|accum, config| {
            let transparency_check = config.supports_transparency().unwrap_or(false)
                & !accum.supports_transparency().unwrap_or(false);

            if transparency_check || config.num_samples() > accum.num_samples() {
                config
            } else {
                accum
            }
        })
        .expect("at least one matching GL config should exist")
}
